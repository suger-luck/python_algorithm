## 算法引入
### 解决问题思路
- 枚举法-->最原始的方法

 
### 算法特性
- 输入： 0个或多个
- 输出：至少一个 或多个
- 有穷性：有限的步骤之后会自动结束，每个步骤可以在可接受的时间内完成
- 确定性：每一步都有确定的含义，不会产生歧义
- 可行性：每一步都是可行的

### 算法衡量效率
- 时间复杂度

#### 最常见的时间复杂度
- 12 
    - O(1)  
    - 常数级
- 2n+3
    - O(n)
    - 线性级
- 3n^2+2n+1
    - O(n^2)
    - 平方级
- 5log(2^n)+20
    - O(logn)
    - 对数级
- 2n + 3nlog(2^n)+19
    - O(nlogn)
    - nlogn级
- 6n^3+2n^2+3n+4
    - O(n^3)
    - 立方级
- 2^n
    - O(2^n)
    - 指数级
    
- 比较
    - O(1) < O(logn) < O(n) < O(nlogn) < O(n^2) < n^2logn < O(n^3) < O(2^n) < O(n!) <O(n^n)
    

### 单链表
- python 中所有的变量名是保存的变量的位置，存的是指向，即数据地址
- 获取某个变量所指向数据的地址， 就是变量名，其指向就是地址
- 数据 + 下一个数据地址
```python
"""
第一个节点为    头结点
最后一个节点为 尾结点
实现一下功能：
是否为空            is_empty()
链表长度            length()
遍历整个列表        travel()
链表头部添加元素    add(item)
链表尾部添加元素    append(item)
指定位置添加元素    insert(pos,item)
删除节点            remove(item)
查找节点是否存在    search(item)
"""
```

- 顺序表 ： 
    - 优点：访问元素的时间复杂度为O(1)， 内存是一块连续的内存
- 链表 ： 
    - 优点： 内存不需要是连续的内存， 访问元素的时间复杂度为O(n), 
    - 不足： 消耗空间较大
    
### 双向链表
- 上一个数据地址 + 数据 + 下一个数据地址

### 数据形式的应用
线性表 ： 数据的存放  list
链表 ： 应用到栈
栈 ： 数据的操作  先进后出
队列 ： 先进先出   树 深度遍历

### 逻辑中的假的值
- 逻辑中假的：  "" 0 {} () []
- 空字符串
- 空元组
- 空字典
- 空列表
- 0

### 排序算法的稳定性
在原有的序列当中相等的位置次序不发生改变

### 排序算法
- 冒泡排序
- 选择排序
- 插入排序
- 快速排序
- 希尔排序
- 归并排序
### 搜索算法
- 二分查找
- 顺序查找
- 二叉树查找
- 哈希查找

## 树
### 种类
- 无序树
- 有序树
    - 二叉树
        - 完全二叉树
        - 满二叉树
        - 平衡二叉树
        - 排序二叉树
    - 哈斯曼树
    - B树
### 存储
- 顺序存储
- 链式存储
### 应用场景
- html、xml 解析
- 路由协议
- mysql数据库索引
- 文件系统的目录结构
- AI算法

### 二叉树遍历
- 广度遍历/ 层次遍历
- 先序遍历
- 中序遍历
- 后序遍历
### 确定一棵树 即给定顺序后将二叉树画出来
- 先中后三种排序给定两种排序，两种排序中必须有中序 
